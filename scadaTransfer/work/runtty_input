#!/bin/bash
umask 002
echo '       runtty_input started'
# run program to handle serial line communication and output file creation
# Loop the running of tty_input to handle weekends

# First, define this function
prompt_user () {
    read -p "$loopprompt" endloop
    until [ "$endloop" = "n" -o "$endloop" = "y" ] 
    do
        read -p "$loopprompt" endloop
    done
}

# Call it once, to see if we need to go to the SCADA at all
loopprompt='Are you finished with the SCADA Terminal (y,n)?'
prompt_user

#then loop until they say they are done with the terminal
until [ "$endloop" = 'y' ]
do 
    echo 'To abort getting input from the SCADA terminal, hit ctrl-C'
    ./tty_input
    prompt_user
done

#tty_input appends the dates it reads to the file 'current_dates'
# this file is removed at the end of this program.
# Check dates
touch current_dates
echo 'Dates currently selected for HDB loading are:'
cat current_dates

loopprompt="Is this set of dates correct? (y,n)? "
prompt_user
until [ "$endloop" = 'y' ]
do 
    #currently only allow either or, and only one time through this loop,
    # so we remove the file to start
    \rm -f current_dates
    touch current_dates
    echo 'Select date type:'
    echo '(1) Sequential (04AUG18 - 04AUG21)'
    echo '(2) Specific (04AUG18, 04AUG22)'
    read date_type

    if [ "$date_type" -eq 1 ]
    then
        read -p 'Enter Beginning Date: ' beg_date
        read -p 'Enter Ending Date: ' end_date
        for date in `./gendates $beg_date $end_date`
        do
            echo $date >>current_dates
        done
        cat current_dates
        prompt_user
    elif [ "$date_type" -eq 2 ]
    then
        until [ "$endloop" = 'y' ]
        do 
            read -p 'Enter Date: ' date

            case "$date" in
                [0][0-9][ADFJMNOS][ACEOPU][BCGLNPRTVY][0-3][0-9])
                    echo $date >>current_dates
                    ;;
                *) #not a date
                    echo "\"$date\" is not a correct date, not placed in list!"
                    ;;
            esac

            cat current_dates
            echo "To empty the date set, hit ctrl-C and start runtty_input over."
            prompt_user
        done
    fi
done

#echo ' '
echo '        Initiating program to load data into Oracle HDB'
#set $1 to first field in this file
if [ ! -s current_dates ]
then
    echo "ERROR! No dates selected, exiting program!"
    exit 1;
fi

for date in `cat current_dates`
do

# application scadaTransfer is run using the applications role
# it has two arguments the name of the log file and the password
# this application can be run independant of this script
# if the log file needs to be edited, edit the file (correct the 
# data - then run the following executable (scadaTransfer)
    echo 'Placing Data into HDB2'
    scadaTransfer crsp_$date.dat app_user uchdb2
    stat=$?
    if [ $stat -ne 0 ]
    then
        echo "scadaTransfer failed, exiting!"
        exit $stat
    fi
done

# ****************
# Run the derivation app to place the data into r_day
# ****************
./derive_scada &

# For testing
#(sleep 2 && /bin/false) &
#/bin/true &

# Get the Process ID (pid) of the last process put in the backgroup
pid=$!
# This application takes a bit of time, so we put it in the background
# we do all the other processing, then wait(1) for the derivation app
# then we can run scadadata, and create the hydromet input file from HDB2
for date in `cat current_dates`
do
    echo '       Transferring data to Flagstaff'
    ./ftp_orca $date
    stat=$?
    if [ $stat -ne 0 ] 
    then
        echo 'ERROR IN DATA TRANSFER TO FLAGSTAFF! Notify Rick or Andrew.'
        echo "Exited with status: $stat."
#Not a fatal error
        exit 1
    fi

    echo '       Mailing data to WAPA'
    ./mail_wapa $date
    stat=$?
    if [ $stat -ne 0 ] 
    then
        echo 'ERROR IN MAILING DATA TO WAPA! Notify Rick or Andrew.'
        echo "Exited with status: $stat."
#Not a fatal error
        exit 1
    fi
done
    echo '' 

# Now we wait
# We use /bin/bash as the shell for this since the
# pure sh shell doesn't hold on to the exit status of the background
# process if it exits before the wait.
echo "        Waiting for derivation application to finish"

wait $pid
stat=$?

#test the result of the wait command
#if the exit status is non-zero and less than 127
# the exit status is from the derivation application
if [ $stat -ne 0 ] 
then
    echo "ERROR IN THE DERIVATION APPLICATION. Exited with status: $stat."
    echo 'The hydromet file was not created. Exiting program.'
    exit 1
fi


echo '       Derivation application done, creating Glen Canyon Power and Total Release, '
echo 'and transferring hydromet input file'
# now run the application to generate the hydromet input file
for date in `cat current_dates`
do
    glenPowRelease app_user uchdb2 $date
    if [ $? -ne 0 ]
    then
        echo "Glen Power Release failed, exiting!"
        exit
    fi

    ./derive_pwr
    if [ $? -ne 0 ]
    then
        echo "derivation for Power Release failed, exiting!"
        exit
    fi

    glenTotRelease app_user uchdb2 $date
    if [ $? -ne 0 ]
    then
        echo "Glen Total Release failed, exiting!"
        exit
    fi

    ./derive_tot
    if [ $? -ne 0 ]
    then
        echo "derivation for Total Release failed, exiting!"
        exit
    fi

    scadaData app_user uchdb2 $date 
    if [ $? -ne 0 ]
    then
        echo "scadaData failed, exiting!"
        exit
    fi
done

\rm -f current_dates

echo '              runtty_input script now complete'
echo '         Please report all errors seen in this script'
exit

