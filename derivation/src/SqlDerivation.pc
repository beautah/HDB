/*****************************************************************************
* DESCRIPTION
*
* This file contains the functions that load changed r_base data from HDB
* and derive it to the interval tables based on user specifications in 
* ref_derivation_source and ref_derivation_destination.
*
***************************************
*
* SqlDerivationControl
*
* Purpose: Contains logic for copying and deriving new and changed r_base
*          data. Loads user specifications and finds the changed data in
*          r_base_update to be derived under each specification.  Calls the
*          SqlCopyBase() and DeriveList() to copy and derive the
*          data up through the interval tables.
*
* Input:   char* sdilist - may be null, comma separated list of sdis to process
*
* Output:  int* - Pointer to number of r_base_update records processed
*
* Return:  int - OK or ERROR
*
***************************************
* SqlCopyBase
*
* Purpose: Copy data from the base area to the appropriate table
*
* Input:   UPDATE_RECORD** - Pointer to array of records from r_base_update
*                            to be copied  
*          int - Number of records in the array
*          REF_SOURCE* - Pointer to a ref_derivation_source specification
*      
* Output:  None
*
* Return:  int - OK or ERROR
*
***************************************
* SqlTimeInterval
*
* Purpose: Based on an update record, determines the beginning and end of the 
*          destination interval that contains the date/time of the record,
*          and the beginning and end of the source data window for this 
*          destination interval
*
* Input:   UPDATE_RECORD* - Pointer to an update record
*          SQL_INTERVAL - destination interval to calculate times for
*          REF_SOURCE* - Optional ref_derivation_source specification pointer
*                        - include only if there is a time offset in the 
*                        source specification that must be accounted for -
*                        if none required, pass in NULL
*
* Output:  INTERVAL_TIME* - Pointer to an interval time structure that the
*                           calculated times will be passed back through 
*
* Return:  int - OK or ERROR
*
***************************************
* SqlTimeShift
*
* Purpose: Takes a time record and shifts it forward or backward by one
*          interval
*
* Input:   INTERVAL_TIME* - Pointer to the existing time record
*          SQL_INTERVAL - interval by which the time should be shifted
*          DATE_MATH_TYPES - Operator (ADDITION or SUBTRACTION) indicating
*                            whether the time record is shifted forward or
*                            backward
*
* Output:  INTERVAL_TIME* - Pointer to the new time record that the shifted
*                           values will be passed back through 
*
* Return:  int - OK or ERROR
*
***************************************
* SqlCreateTable
*
* Purpose: Create the r_interval_update table for this run of the 
*          derivation application.  Acts as a semafore to prevent
*          multiple copies of the derivation app being started on
*          the same database  
*
* Input:   None
*
* Output:  None    
*
* Return:  int - OK or ERROR
*
***************************************
* SqlDropTable
*
* Purpose: Drops the r_interval_update table at the conclusion of this
*          run of the derivation app.  Frees the semafore to allow the
*          next run of the app to be started.   
*
* Input:   None
*
* Output:  None    
*
* Return:  int - OK or ERROR
*
***************************************
* LoadDestination
*
* Purpose: Moves a ref_destination spec into a structure - includes
*          checking the sql indicator variable for NULLs and loading
*          the structure appropriately based on the indicator.   
*
* Input:   REF_DESTINATION* - Pointer to ref_destination spec
*          IND_DESTINATION* - Pointer to indicator for the ref_destination spec
*
* Output:  REF_DESTINATION* - Pointer to output spec initialized appropriately
*
* Return:  int - OK or ERROR
*
***************************************
* SqlUpdateSelect
*
* Purpose: Selects update data of a specified site datatype id and interval
*          from r_interval_update 
*
* Input:   int - site datatype id to be selected
*          SQL_INTERVAL - interval to be selected
*
* Output:  int* - Pointer to an integer returning the number of records selected
*          UPDATE_RECORD** - Reference to a pointer to a list of the returned
*                            update records
*
* Return:  int - OK or ERROR
*
***************************************
* SqlRemoveOldUpdates
*
* Purpose: Removes entries from r_base_update that are over one year old. 
*          These could no longer function as the one latest residual value
*          to keep to make sure a partial calc at the longest interval (year) 
*          is made final. At this point they represent an SDI that no longer
*           has new data coming in
*
* Input:   None
*
* Output:  None
*
* Return:  int - OK or ERROR
*
***************************************
*
* Author
*
* Neil Wilson
* September, 2001
****************************************************************************/
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "utils.h"
#include "dbutils.h"
#include "defines.h"
#include "typedefs.h"
#include "derivation.h"
#include "derivationTypedefs.h"

extern SQL_DATE DATETIMELOADED;
extern FILE* LOGFILE;

EXEC SQL INCLUDE sqlca;

#define FUNC_NAME "SqlDerivationControl"

int SqlDerivationControl(int* baseUpdateTotal, char * sdilist)
{
   EXEC SQL BEGIN DECLARE SECTION;
      char sqlSelectStatement[1500];
      char sdiCountStatement[1500];
      char sdiSourceStatement[1500];
      char sqlMarkDeleteStatement[600];
      IND_DESTINATION sqlIndDestination;
      IND_SOURCE sqlIndSource;
      int sqlSourceCount;
      REF_DESTINATION sqlRefDestination;
      REF_SOURCE sqlRefSource;
      UPDATE_RECORD* sqlUpdateRecord;
   EXEC SQL END DECLARE SECTION;

   char selectStatement[600];
   int baseUpdateIndex = 0;
   int baseUpdateCount = 0;
   int compCount;
   int compIndex;
   int compOrd;
   int compSDI;
   int compUpdateCount;
   int dataOrd;
   int destCount;
   int destIndex;
   int firstDestOrd;
   int intervalLoop;
   int intUpdateCount;
   int result;
   int sourceIndex = 0;
   int TOTALNUMINT;
   int valid;
   REF_DESTINATION* compSpecList;
   REF_DESTINATION* destSpecList;
   REF_SOURCE* sourceSpecList;
   SQL_INTERVAL firstDestName;
   SQL_INTERVAL compIntName;
   SQL_INTERVAL compIntSource;
   SQL_INTERVAL updateIntName;
   SQL_INTERVAL updateIntSource;
   UPDATE_RECORD* compUpdateList;
   UPDATE_RECORD* intUpdateDataList = NULL;
   UPDATE_RECORD* updateDataList;


            if ((result = SqlGetPreviousIntName("day",
                          compIntSource,
                          &valid)) != OK)
            {
               FilePrintError(LOGFILE, "Problem finding previous interval name for interval %s\n", compIntName);
               return (ERROR);
            }

   /* Retrieve the number of intervals in HDB */
   if ((result = SqlIntervalCount(&TOTALNUMINT)) != OK)
   {
      FilePrintError(LOGFILE, "Problem querying hdb_interval table");
      return (ERROR);
   }

   /* Handle possible limitation on sdis to process
      by creating an SQL where clause to limit the sdis returned*/
   if (sdilist)
   {
      sprintf(sdiCountStatement, "SELECT COUNT(*) "
      "FROM ref_derivation_source WHERE site_datatype_id IN ( %s )", sdilist);
   } else
   {
      sprintf(sdiCountStatement, "SELECT COUNT(*) FROM ref_derivation_source");
   }
   
   /* Load all of the ref_derivation_source entries */
   /* Find how many entries in ref_derivation_source */
   /* Use SelectCount because this may be a dynamic query */
   if ((result = SqlSelectCount(sdiCountStatement, &sqlSourceCount)) != OK)
      {
         FilePrintError(LOGFILE,
                   "Problem querying row count in ref_derivation_source\n");
         EXEC SQL ROLLBACK;
         return (ERROR);
      }

   /* Create array of structures to hold ref_derivation_source data */
   if (sqlSourceCount)
   {
      if ((sourceSpecList = (REF_SOURCE *) malloc 
         (sizeof(REF_SOURCE) * sqlSourceCount)) == NULL)
      {
         FilePrintError(LOGFILE, 
                        "Problem allocating memory for sourceSpecList\n");
         return (ERROR);
      }
   }
   else
   {
      sourceSpecList = NULL;
   }

   /* Handle possible limitation on sdis to process
      by creating an SQL where clause to limit the sdis returned */
   if (sdilist)
   {
      sprintf(sdiSourceStatement, "SELECT site_datatype_id, interval, first_destination_interval, min_value_expected, min_value_cutoff, max_value_expected, max_value_cutoff, time_offset_minutes FROM ref_derivation_source WHERE site_datatype_id IN ( %s )", sdilist);
   } else
   {
      sprintf(sdiSourceStatement, "SELECT site_datatype_id, interval, first_destination_interval, min_value_expected, min_value_cutoff, max_value_expected, max_value_cutoff, time_offset_minutes FROM ref_derivation_source");
   }

   /* prepare the source selection statement */
   EXEC SQL PREPARE source_sel FROM :sdiSourceStatement;
   
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
      "Problem preparing source_cursor\n")) != OK)
   {
         return (ERROR);
   }

   /* Declare source_cursor for selecting ref_derivation_source data */
   EXEC SQL DECLARE source_cursor CURSOR FOR source_sel;
   
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
      "Problem declaring source_cursor\n")) != OK)
   {
         return (ERROR);
   }

   /* Open source_cursor */
   EXEC SQL OPEN source_cursor;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
      "Problem opening source_cursor\n")) != OK)
   {
      return (ERROR);
   }

   EXEC SQL WHENEVER NOT FOUND GOTO close_source_cursor;

   /* Fetch ref_derivation_source data */
   for (sourceIndex = 0; sourceIndex < sqlSourceCount ; sourceIndex++)
   {
      EXEC SQL FETCH source_cursor INTO :sqlRefSource INDICATOR :sqlIndSource;

      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
         "Problem fetching source_cursor\n")) != OK)
      {
         EXEC SQL ROLLBACK;
         return (ERROR);
      }

      /* Load current element of sourceSpecList - check for NULLs */
      sourceSpecList[sourceIndex].siteDatatypeId = sqlRefSource.siteDatatypeId;
      strcpy (sourceSpecList[sourceIndex].interval, sqlRefSource.interval);
      if (sqlIndSource.firstDestInterval_ind == -1)
      {
         strcpy (sourceSpecList[sourceIndex].firstDestInterval, EMPTY_STRING);
      }
      else
      {
         strcpy (sourceSpecList[sourceIndex].firstDestInterval, 
                 sqlRefSource.firstDestInterval);
      }
      if (sqlIndSource.minValueExpected_ind == -1)
      {
         sourceSpecList[sourceIndex].minValueExpected = VALUE_NULL;
      }
      else
      {
         sourceSpecList[sourceIndex].minValueExpected = 
                                     sqlRefSource.minValueExpected;
      }
      if (sqlIndSource.minValueCutoff_ind == -1)
      {
         sourceSpecList[sourceIndex].minValueCutoff = VALUE_NULL;
      }
      else
      {
         sourceSpecList[sourceIndex].minValueCutoff = 
                                     sqlRefSource.minValueCutoff;
      }
      if (sqlIndSource.maxValueExpected_ind == -1)
      {
         sourceSpecList[sourceIndex].maxValueExpected = VALUE_NULL;
      }
      else
      {
         sourceSpecList[sourceIndex].maxValueExpected = 
                                     sqlRefSource.maxValueExpected;
      }
      if (sqlIndSource.maxValueCutoff_ind == -1)
      {
         sourceSpecList[sourceIndex].maxValueCutoff = VALUE_NULL;
      }
      else
      {
         sourceSpecList[sourceIndex].maxValueCutoff = 
                                     sqlRefSource.maxValueCutoff;
      }
      if (sqlIndSource.timeOffset_ind == -1)
      {
         sourceSpecList[sourceIndex].timeOffsetMinutes = VALUE_NULL;
      }
      else
      {
         sourceSpecList[sourceIndex].timeOffsetMinutes = 
                                     sqlRefSource.timeOffsetMinutes;
      }
   }

   /* Close source cursor */
   close_source_cursor:
   EXEC SQL CLOSE source_cursor;
   EXEC SQL COMMIT;
   EXEC SQL WHENEVER NOT FOUND CONTINUE;

   /* Loop for each ref_derivation_source entry */
   for (sourceIndex = 0; sourceIndex < sqlSourceCount; sourceIndex++)
   {
      /* For test, print to log file that we are starting to process this SDI */
      /* fprintf(LOGFILE, " Started processing of  SDI = %d.\n", sourceSpecList[sourceIndex].siteDatatypeId); */

      /* Mark the rows with this SDI in r_base_update to tag ones we are going
         to process - if one gets updated while we are processing, the tag 
         gets removed by the update trigger so we don't later delete that row.
         It then gets processed by the next run of the app */
      sprintf(sqlMarkDeleteStatement, "UPDATE r_base_update SET ready_for_delete = 'Y' WHERE site_datatype_id = %d AND interval = '%s' AND overwrite_flag IS NULL", sourceSpecList[sourceIndex].siteDatatypeId, sourceSpecList[sourceIndex].interval);
      EXEC SQL PREPARE mark FROM :sqlMarkDeleteStatement;
      EXEC SQL EXECUTE mark;

      /* TRUE used in second argument to SqlFilePrintErrorHandler because
         it is OK if no rows were processed above - means were no 
         records to mark for this SDI */
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, TRUE, 
                    "Problem marking nonoverwrite records in r_base_update as ready for delete\n")) != OK)
      {
         EXEC SQL ROLLBACK;
         return (ERROR);
      }

      /* Load rows from r_base_update related to ref_derivation_source spec */
      /* Find out how many applicable rows in r_base_update */
      sprintf(selectStatement, "SELECT COUNT(*) FROM r_base_update WHERE site_datatype_id = %d AND interval = '%s' AND overwrite_flag IS NULL", sourceSpecList[sourceIndex].siteDatatypeId, sourceSpecList[sourceIndex].interval);

      if ((result = SqlSelectCount(selectStatement, &baseUpdateCount)) != OK)
      {
         FilePrintError(LOGFILE,
                        "Problem querying row count in r_base_update\n");
         return (ERROR);
      }

      *baseUpdateTotal = *baseUpdateTotal + baseUpdateCount;

      /* Create array of structures to hold r_base_update data */
      if (baseUpdateCount)
      {
         if ((updateDataList = (UPDATE_RECORD *) malloc 
            (sizeof(UPDATE_RECORD) * (baseUpdateCount))) == NULL)
         {
             FilePrintError(LOGFILE,
                            "Problem allocating memory for updateDataList\n");
             return (ERROR);
         }
      }
      else
      {
         updateDataList = NULL;
      }

      /* Prepare the select statement for r_base_update data*/
      sprintf (sqlSelectStatement, "SELECT site_datatype_id, TO_CHAR (start_date_time, 'DD-MON-YYYY HH24:MI:SS'), TO_CHAR (end_date_time, 'DD-MON-YYYY HH24:MI:SS'), interval FROM r_base_update WHERE site_datatype_id = %d AND interval = '%s' AND overwrite_flag IS NULL ORDER BY start_date_time", sourceSpecList[sourceIndex].siteDatatypeId, sourceSpecList[sourceIndex].interval);

      EXEC SQL PREPARE sel FROM :sqlSelectStatement;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                    "Problem preparing select statement: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      /* Declare base_update_cursor for selecting r_base_update data */
      EXEC SQL DECLARE base_update_cursor CURSOR FOR sel;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                    "Problem declaring base_update_cursor for: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      /* Open base_update_cursor */
      EXEC SQL OPEN base_update_cursor;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                    "Problem opening base_update_cursor for\n: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      EXEC SQL WHENEVER NOT FOUND GOTO close_base_update_cursor;

      /* Fetch applicable r_base_update data */ 
      for (baseUpdateIndex = 0; baseUpdateIndex < baseUpdateCount ;
           baseUpdateIndex++)
      {
         sqlUpdateRecord = &updateDataList[baseUpdateIndex];

         EXEC SQL FETCH base_update_cursor INTO
                                :sqlUpdateRecord->siteDatatypeId, 
                                :sqlUpdateRecord->startDateTime,
                                :sqlUpdateRecord->endDateTime,
                                :sqlUpdateRecord->interval;
         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
            "Problem fetching base_update_cursor for\n: %s...\n",
                    sqlSelectStatement)) != OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }
      }

      /* Close base_update_cursor */
      close_base_update_cursor:
      EXEC SQL CLOSE base_update_cursor;
      EXEC SQL COMMIT;
      EXEC SQL WHENEVER NOT FOUND CONTINUE;

      /* Call to SqlCopyBase to copy base values to corresponding tables */
      if ((result = SqlCopyBase(updateDataList, baseUpdateCount,
                    &sourceSpecList[sourceIndex])) != OK)
      {
         FilePrintError(LOGFILE,
                        "Problem copying r_base values to corresponding tables\n");
         return (ERROR);
      }

      /* Load all noncompounded ref_derivation_destination entries that 
         are specified for the current ref_derivation_source */
      /* Find how many relevant entries are in ref_derivation_destination */
      sprintf(selectStatement, "SELECT COUNT(*) FROM ref_derivation_destination WHERE base_site_datatype_id = %d AND compounding_source_sdi IS NULL", sourceSpecList[sourceIndex].siteDatatypeId);

      if ((result = SqlSelectCount(selectStatement, &destCount)) != OK)
      {
         FilePrintError(LOGFILE,
                        "Problem querying row count in ref_derivation_destination\n");
         return (ERROR);
      }

      /* Create array of structures to hold ref_derivation_destination data */
      if (destCount)
      {
         if ((destSpecList = (REF_DESTINATION *) malloc 
            (sizeof(REF_DESTINATION) * destCount)) == NULL)
         {
            FilePrintError(LOGFILE,
                           "Problem allocating memory for destSpecList\n");
            return (ERROR);
         }
      }
      else
      {
         destSpecList = NULL;
      }

      /* Prepare the select statement for ref_derivation_destination data*/
      sprintf (sqlSelectStatement, "SELECT r.base_site_datatype_id, r.compounding_source_sdi, r.compounding_source_interval, r.dest_site_datatype_id, r.partial_calc, r.method_id, r.hr_desired_eop_window, r.hr_required_eop_window, r.hr_desired_bop_window, r.hr_required_bop_window, r.hr_window_unit, r.hr_desired_number_source, r.hr_required_number_source, r.day_desired_eop_window, r.day_required_eop_window, r.day_desired_bop_window, r.day_required_bop_window, r.day_window_unit, r.day_desired_number_source, r.day_required_number_source, r.mon_desired_eop_window, r.mon_required_eop_window, r.mon_desired_bop_window, r.mon_required_bop_window, r.mon_window_unit, r.mon_desired_number_source, r.mon_required_number_source, r.yr_desired_eop_window, r.yr_required_eop_window, r.yr_desired_bop_window, r.yr_required_bop_window, r.yr_window_unit, r.yr_desired_number_source, r.yr_required_number_source, r.wy_desired_eop_window, r.wy_required_eop_window, r.wy_desired_bop_window, r.wy_required_bop_window, r.wy_window_unit, r.wy_desired_number_source, r.wy_required_number_source FROM ref_derivation_destination r WHERE r.base_site_datatype_id = %d AND r.compounding_source_sdi IS NULL ", sourceSpecList[sourceIndex].siteDatatypeId);

      EXEC SQL PREPARE sel FROM :sqlSelectStatement;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                    "Problem preparing select statement: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      /* Declare dest_cursor for selecting ref_derivation_destination data */
      EXEC SQL DECLARE dest_cursor CURSOR FOR sel;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                    "Problem declaring dest_cursor for: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      /* Open dest_cursor */
      EXEC SQL OPEN dest_cursor;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                    "Problem opening dest_cursor for\n: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      EXEC SQL WHENEVER NOT FOUND GOTO close_dest_cursor;

      /* Fetch applicable ref_derivation_destination data */ 
      for (destIndex = 0; destIndex < destCount ; destIndex++)
      {
         EXEC SQL FETCH dest_cursor INTO :sqlRefDestination INDICATOR :sqlIndDestination; 

         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
            "Problem fetching dest_cursor for\n: %s...\n",
                    sqlSelectStatement)) != OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }

         if ((result = LoadDestination(
                       &sqlRefDestination,
                       &sqlIndDestination,
                       &destSpecList[destIndex])) != OK)
         {
            FilePrintError(LOGFILE,
                           "Problem loading destination specification.");
            return (ERROR);
         }
      }

      /* Close dest_cursor */
      close_dest_cursor:
      EXEC SQL CLOSE dest_cursor;
      EXEC SQL COMMIT;
      EXEC SQL WHENEVER NOT FOUND CONTINUE;


            if ((result = SqlGetPreviousIntName("day",
                          compIntSource,
                          &valid)) != OK)
            {
               FilePrintError(LOGFILE, "Problem finding previous interval name for interval %s\n", compIntName);
               return (ERROR);
            }

      /* Determine order number for the interval of the data */
      if ((result = SqlGetIntOrder(
                    sourceSpecList[sourceIndex].interval,
                    &dataOrd)) != OK)
      {
         FilePrintError(LOGFILE, "Problem finding interval order number of %s\n", sourceSpecList[sourceIndex].interval);
         return (ERROR);
      }

      /* Determine the order number and name of the first destination interval
         - is the same for all noncompounded destination specs */
      if (dataOrd == 1)
      {
         /* First destination for nonbusiness interval data must be specified
            in the firstDestInterval parameter.  Nonbusiness intervals
            have an interval order of 1 - current examples are "instant"
            and "other". */
         if (!strcmp(sourceSpecList[sourceIndex].firstDestInterval, EMPTY_STRING))
         {
             FilePrintError(LOGFILE, "A ref_derivation_source specification for interval = %s must have the first destination interval specified (error at site_datatype_id = %d)\n", sourceSpecList[sourceIndex].interval, sourceSpecList[sourceIndex].siteDatatypeId);
            return (ERROR);
         }
         strcpy (firstDestName, 
                 sourceSpecList[sourceIndex].firstDestInterval);
         if ((result = SqlGetIntOrder(
                       sourceSpecList[sourceIndex].firstDestInterval,
                       &firstDestOrd)) != OK)
         {
            FilePrintError(LOGFILE, "Problem finding interval order number of %s\n", sourceSpecList[sourceIndex].firstDestInterval);
            return (ERROR);
         } 
      }
      else
      {
         /* First destination for business interval data is one higher than 
            the interval of the data itself */
         firstDestOrd = dataOrd + 1;
         if ((result = SqlGetIntName(firstDestOrd, firstDestName)) != OK)
         {
            FilePrintError(LOGFILE, "Problem finding interval name for order number %d\n", firstDestOrd);
            return (ERROR);
         }
 
      }

      /* Loop through each ref_derivation_destination entry */
      for (destIndex = 0; destIndex < destCount; destIndex++)
      {
         /* Derive r_base_update entries to the first interval based on the
            ref_derivation_destination spec */
         if ((result = DeriveList(
                          firstDestName,
                          updateDataList,
                          baseUpdateCount,
                          &sourceSpecList[sourceIndex],
                          &destSpecList[destIndex])) != OK)
         {
            FilePrintError(LOGFILE, "Problem deriving r_base data to first interval\n");
            return (ERROR);
         }
         
         /* Loop and derive values up through the remaining intervals */
         for (intervalLoop = firstDestOrd + 1; intervalLoop <= TOTALNUMINT;
              intervalLoop++) 
         {
            /* Find the name of the interval */
            if ((result = SqlGetIntName(intervalLoop, updateIntName)) != OK)
            {
               FilePrintError(LOGFILE, "Problem finding interval name for order number %d\n", intervalLoop);
               return (ERROR);
            }
            
            /* Find name of previous interval that will be the data source */
            if ((result = SqlGetPreviousIntName(updateIntName,
                          updateIntSource,
                          &valid)) != OK)
            {
               FilePrintError(LOGFILE, "Problem finding previous interval name for interval %s\n", updateIntName);
               return (ERROR);
            }
            /* Check if previous interval is valid - always should be here,
               but if not, return error */
            if (valid == 0)
            {
               FilePrintError(LOGFILE, "Previous interval name not valid for interval %s\n", updateIntName);
               return (ERROR);               
            }

            if (!strncmp(firstDestName, "ye", 2))
            {
               /* The first destination interval derivation was to year. 
                  In this case the base interval for derivation to wy will 
                  be the same as for year so the source data will be from 
                  table r_base_update */ 
               if ((result = DeriveList(
                               updateIntName,
                               updateDataList,
                               baseUpdateCount,
                               &sourceSpecList[sourceIndex],
                               &destSpecList[destIndex])) != OK)
               {
                  FilePrintError(LOGFILE, "Problem deriving r_base data to interval %s.\n", updateIntName);
                  return (ERROR);
               }
            }
            else
            {

               /* Source data will be from r_interval_update */

               /* Select the desired data from r_interval_update */
               if ((result = SqlUpdateSelect(
                                destSpecList[destIndex].destSDI,
                                updateIntSource,
                                &intUpdateCount,
                                &intUpdateDataList)) != OK)
               {
                  FilePrintError(LOGFILE, "Problem selecting data from r_interval_update for SDI %d and interval %s./n", destSpecList[destIndex].destSDI, updateIntSource);
                  return (ERROR);
               }

               /* Derive r_interval_update data to the interval based
                  on the ref_derivation_destination spec */
               if ((result = DeriveList(
                                updateIntName,
                                intUpdateDataList,
                                intUpdateCount,
                                &sourceSpecList[sourceIndex],
                                &destSpecList[destIndex])) != OK)
               {
                  FilePrintError(LOGFILE, "Problem deriving interval values upward\n");
                  return (ERROR);
               }
            } 

            /* Free the memory for the intUpdateDataList */
            if (intUpdateDataList != NULL)
            {
               free(intUpdateDataList);
               intUpdateDataList = NULL;
            }
         }
      }
      /* Free the memory for the destSpecList */
      if (destSpecList != NULL)
      {
         free(destSpecList);
         destSpecList = NULL;
      }

      /* CODE FOR HANDLING COMPOUNDED ROWS FROM ref_derivation_destination */

      /* Load all compounded ref_derivation_destination entries that 
         are specified for the current ref_derivation_source */
      /* Find how many relevant entries are in ref_derivation_destination */
      sprintf(selectStatement, "SELECT COUNT(*) FROM ref_derivation_destination WHERE base_site_datatype_id = %d AND compounding_source_sdi IS NOT NULL", sourceSpecList[sourceIndex].siteDatatypeId);

      if ((result = SqlSelectCount(selectStatement, &compCount)) != OK)
      {
         FilePrintError(LOGFILE, "Problem querying compound row count in ref_derivation_destination\n");
         return (ERROR);
      }

      /* Create array of structures to hold compound 
         ref_derivation_destination data */
      if (compCount)
      {
         if ((compSpecList = (REF_DESTINATION *) malloc 
            (sizeof(REF_DESTINATION) * compCount)) == NULL)
         {
            FilePrintError(LOGFILE, "Problem allocating memory for compSpecList\n");
            return (ERROR);
         }
      }
      else
      {
         compSpecList = NULL;
      }

      /* Prepare the select statement for compound 
         ref_derivation_destination data */
      sprintf (sqlSelectStatement, "SELECT r.base_site_datatype_id, r.compounding_source_sdi, r.compounding_source_interval, r.dest_site_datatype_id, r.partial_calc, r.method_id, r.hr_desired_eop_window, r.hr_required_eop_window, r.hr_desired_bop_window, r.hr_required_bop_window, r.hr_window_unit, r.hr_desired_number_source, r.hr_required_number_source, r.day_desired_eop_window, r.day_required_eop_window, r.day_desired_bop_window, r.day_required_bop_window, r.day_window_unit, r.day_desired_number_source, r.day_required_number_source, r.mon_desired_eop_window, r.mon_required_eop_window, r.mon_desired_bop_window, r.mon_required_bop_window, r.mon_window_unit, r.mon_desired_number_source, r.mon_required_number_source, r.yr_desired_eop_window, r.yr_required_eop_window, r.yr_desired_bop_window, r.yr_required_bop_window, r.yr_window_unit, r.yr_desired_number_source, r.yr_required_number_source, r.wy_desired_eop_window, r.wy_required_eop_window, r.wy_desired_bop_window, r.wy_required_bop_window, r.wy_window_unit, r.wy_desired_number_source, r.wy_required_number_source FROM ref_derivation_destination r WHERE r.base_site_datatype_id = %d AND r.compounding_source_sdi IS NOT NULL ", sourceSpecList[sourceIndex].siteDatatypeId);

      EXEC SQL PREPARE comp FROM :sqlSelectStatement;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                    "Problem preparing select statement: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      /* Declare comp_cursor for selecting compound 
         ref_derivation_destination data */
      EXEC SQL DECLARE comp_cursor CURSOR FOR comp;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                    "Problem declaring comp_cursor for: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      /* Open comp_cursor */
      EXEC SQL OPEN comp_cursor;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                    "Problem opening comp_cursor for\n: %s...\n",
                    sqlSelectStatement)) != OK)
      {
         return (ERROR);
      }

      EXEC SQL WHENEVER NOT FOUND GOTO close_comp_cursor;

      /* Fetch applicable compound ref_derivation_destination data */ 
      for (compIndex = 0; compIndex < compCount ; compIndex++)
      {
         EXEC SQL FETCH comp_cursor INTO :sqlRefDestination INDICATOR :sqlIndDestination; 

         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
            "Problem fetching comp_cursor for\n: %s...\n",
                    sqlSelectStatement)) != OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }

         if ((result = LoadDestination(
                       &sqlRefDestination,
                       &sqlIndDestination,
                       &compSpecList[compIndex])) != OK)
         {
            FilePrintError(LOGFILE, "Problem loading compound destination specification.");
            return (ERROR);
         }
      }

      /* Close comp_cursor */
      close_comp_cursor:
      EXEC SQL CLOSE comp_cursor;
      EXEC SQL COMMIT;
      EXEC SQL WHENEVER NOT FOUND CONTINUE;

      /* Loop through each compound ref_derivation_destination entry */
      for (compIndex = 0; compIndex < compCount; compIndex++)
      {
         /* Determine order number for the compounding source interval */
         if ((result = SqlGetIntOrder(
                       compSpecList[compIndex].compoundingSourceInterval,
                       &compOrd)) != OK)
         {
            FilePrintError(LOGFILE, "Problem finding interval order number of %s\n", compSpecList[compIndex].compoundingSourceInterval);
            return (ERROR);
         }

         /* Loop and derive values up through the intervals */
         for (intervalLoop = compOrd + 1; intervalLoop <= TOTALNUMINT;
              intervalLoop++) 
         {
            /* Find the name of the interval */
            if ((result = SqlGetIntName(intervalLoop, compIntName)) != OK)
            {
               FilePrintError(LOGFILE, "Problem finding interval name for order number %d\n", intervalLoop);
               return (ERROR);
            }
            
            /* Find name of previous interval that will be the data source */
            if ((result = SqlGetPreviousIntName(compIntName,
                          compIntSource,
                          &valid)) != OK)
            {
               FilePrintError(LOGFILE, "Problem finding previous interval name for interval %s\n", compIntName);
               return (ERROR);
            }

            /* Check if previous interval is valid - always should be here,
               but if not, return error */
            if (valid == 0)
            {
               FilePrintError(LOGFILE, "Previous interval name not valid for interval %s\n", compIntName);
               return (ERROR);               
            }

            /* Set the SDI for the source data query */
            if (intervalLoop == compOrd+1)
            {
               /* This is the first derivation, so source SDI is specified in 
                  the compound ref_derivation_destination spec */
               compSDI = compSpecList[compIndex].compoundingSourceSDI;
            }
            else
            {
               /* SDI is the dest SDI that was derived during the previous
                  interval iteration */
               compSDI = compSpecList[compIndex].destSDI;
            }

            /* Select the desired data from r_interval_update */
            if ((result = SqlUpdateSelect(
                             compSDI,
                             compIntSource,
                             &compUpdateCount,
                             &compUpdateList)) != OK)
            {
               FilePrintError(LOGFILE, "Problem selecting compound data from r_interval_update for SDI %d and interval %s./n", compSpecList[compIndex].compoundingSourceSDI, compIntSource);
               return (ERROR);
            }

            /* Derive the compound r_interval_update data to the interval based
               on the compound ref_derivation_destination spec */
            if ((result = DeriveList(
                             compIntName,
                             compUpdateList,
                             compUpdateCount,
                             &sourceSpecList[sourceIndex],
                             &compSpecList[compIndex])) != OK)
            {
               FilePrintError(LOGFILE, "Problem deriving compound interval values upward\n");
               return (ERROR);
            }

            /* Free the memory for the compUpdateList */
            if (compUpdateList != NULL)
            {
               free(compUpdateList);
               compUpdateList = NULL;
            }
         }

      }

      /* Free the memory for the compSpecList */
      if (compSpecList != NULL)
      {
         free(compSpecList);
         compSpecList = NULL;
      }

      /* Make sure all changes are committed */
      EXEC SQL COMMIT;     

      /* Delete r_base_update records for the current SDI */
      if (baseUpdateCount)
      {
         /* Mark as a seed record the most recent loaded record for
            this SDI  - keeping this one will ensure completion of partial
            calcs next time the app runs */
         sqlUpdateRecord = &updateDataList[baseUpdateCount - 1];
         EXEC SQL UPDATE r_base_update
            SET ready_for_delete = 'S'
            WHERE site_datatype_id = :sqlUpdateRecord->siteDatatypeId
              AND start_date_time = TO_DATE (:sqlUpdateRecord->startDateTime,
                                        'DD-MON-YYYY HH24:MI:SS')
              AND end_date_time = TO_DATE (:sqlUpdateRecord->endDateTime,
                                        'DD-MON-YYYY HH24:MI:SS')
              AND interval = :sqlUpdateRecord->interval
              AND overwrite_flag IS NULL;
         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                       "Problem marking seed record in r_base_update\n")) != OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }
         EXEC SQL COMMIT;  

         /* Then delete all the other entries from the r_base_update table for
            this SDI that are marked as ready for delete */
         EXEC SQL DELETE FROM r_base_update
            WHERE site_datatype_id = :sqlUpdateRecord->siteDatatypeId
               AND interval = :sqlUpdateRecord->interval
               AND overwrite_flag IS NULL
               AND ready_for_delete = 'Y';
         /* TRUE used in second argument to SqlFilePrintErrorHandler because it
            is OK if no rows were processed above - with records getting
            unmarked could be none left to delete */
         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, TRUE,
                       "Problem deleting records from r_base_update\n")) != OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }
         EXEC SQL COMMIT;           
      }

      /* Free the memory for the updateDataList */
      if (updateDataList != NULL)
      {
         free(updateDataList);
         updateDataList = NULL; 
      }

      /* For test, print to log file that we completed processing this SDI */
      /* fprintf(LOGFILE, " Completed processing of  SDI = %d.\n", sourceSpecList[sourceIndex].siteDatatypeId); */
   }

   /* Free the memory for the sourceSpecList */
   if (sourceSpecList != NULL)
   {
      free(sourceSpecList);
      sourceSpecList = NULL; 
   }

   return (OK);

}

/****************************************************************************/
#define FUNC_NAME "SqlCopyBase"

int SqlCopyBase(UPDATE_RECORD* updateList, int updateCount,
                REF_SOURCE* refSource)
{
   /* Copy data from the base area to the appropriate table */

   EXEC SQL BEGIN DECLARE SECTION;
      char sqlDeleteStatement[600];
      char sqlInsertStatement[600];
      char sqlUpdateStatement[600];
      DATA_RECORD sqlDataRecord;
      IND sqlDerFlag_ind = 0;
      INTERVAL_TIME sqlIntervalTime;
      int sqlCountBase;
      int sqlCountSource;
      UPDATE_RECORD* sqlUpdateRecord;
   EXEC SQL END DECLARE SECTION;

   char intervalTable[12];
   char selectStatement[600];
   int countDestination;
   int order;
   int result;
   int updateIndex;
   int valid;

   /* Create the destination interval table name */
   sprintf (intervalTable, "r_%s", refSource->interval);

   /* Create and prepare delete statement for the destination table for 
      use in data processing loops below (Dynamic SQL Method 2) */
   sprintf(sqlDeleteStatement, "DELETE FROM %s WHERE site_datatype_id = %d AND start_date_time = TO_DATE (:a, 'DD-MON-YYYY HH24:MI:SS') AND end_date_time = TO_DATE (:b, 'DD-MON-YYYY HH24:MI:SS')", intervalTable, refSource->siteDatatypeId);
   EXEC SQL PREPARE del FROM :sqlDeleteStatement;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                "Problem preparing statement %s\n", sqlDeleteStatement)) != OK)
   {
      EXEC SQL ROLLBACK;
      return (ERROR);
   }      

   /* Create and prepare insert statement for the destination table for 
      use in data processing loops below (Dynamic SQL Method 2) */
   sprintf(sqlInsertStatement, "INSERT INTO %s (site_datatype_id, start_date_time, end_date_time, value, overwrite_flag, method_id, derivation_flags, date_time_loaded, validation) VALUES (:a, TO_DATE (:b, 'DD-MON-YYYY HH24:MI:SS'), TO_DATE (:c, 'DD-MON-YYYY HH24:MI:SS'), :d, NULL, :g, :h, TO_DATE (:j, 'DD-MON-YYYY HH24:MI:SS'), NULL)", intervalTable);
   EXEC SQL PREPARE ins FROM :sqlInsertStatement;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                "Problem preparing statement %s\n", sqlInsertStatement)) != OK)
   {
      EXEC SQL ROLLBACK;
      return (ERROR);
   }      

   /* Create and prepare update statement for the destination table for
      use in data processing loops below (Dynamic SQL Method 2) */
   sprintf(sqlUpdateStatement, "UPDATE %s SET value = :c, overwrite_flag = NULL, method_id = :f, derivation_flags = :g, date_time_loaded = TO_DATE (:i, 'DD-MON-YYYY HH24:MI:SS') WHERE site_datatype_id = :j AND start_date_time = TO_DATE (:k, 'DD-MON-YYYY HH24:MI:SS') AND end_date_time = TO_DATE (:l, 'DD-MON-YYYY HH24:MI:SS')", intervalTable);
   EXEC SQL PREPARE upd FROM :sqlUpdateStatement;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                "Problem preparing statement %s\n", sqlUpdateStatement)) != OK)
   {
      EXEC SQL ROLLBACK;
      return (ERROR);
   }      

   /* Get the order of the interval we are looking at */
   if ((result = SqlGetIntOrder(refSource->interval, &order))
                 != OK)
   {
      FilePrintError(LOGFILE, "Problem getting interval order number for %s\n",
                  refSource->interval);
      return (ERROR);
   }

   /* Check if values are not one of the regular business intervals (this
      can be determined by checking if the interval order is 1. Current
      examples of this are the intervals "instant" and "other".) Copy
      process is different for these nonbusiness intervals */   
   if (order == 1)
   {
      /* Step through data list and insert, update, or delete in destination
         table */
      for (updateIndex = 0; updateIndex < updateCount ; updateIndex++)
      {
         sqlUpdateRecord = &updateList[updateIndex];

         /* Look for the value in r_base */
         EXEC SQL
            SELECT COUNT(*) INTO :sqlCountBase
            FROM r_base 
            WHERE site_datatype_id = :sqlUpdateRecord->siteDatatypeId
               AND start_date_time = TO_DATE (:sqlUpdateRecord->startDateTime,
                                        'DD-MON-YYYY HH24:MI:SS')
               AND end_date_time = TO_DATE (:sqlUpdateRecord->endDateTime,
                                        'DD-MON-YYYY HH24:MI:SS')
               AND interval = :sqlUpdateRecord->interval
               AND overwrite_flag IS NULL;

         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                       "Problem querying for count of data in r_base\n"))
                        != OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }

         /* If the value does not exist in r_base, entry represents a delete
            from the base area, so also delete the value from the destination
            table if it exists */
         if (sqlCountBase == 0)
         {
            EXEC SQL EXECUTE del USING :sqlUpdateRecord->startDateTime, :sqlUpdateRecord->endDateTime;

            /* TRUE used in second argument to SqlFilePrintErrorHandler because
               it is OK if no rows were processed above - means a value hadn't 
               been previously copied to the destination table */
            if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, TRUE, 
                          "Problem deleting data record from %s\n", 
                          intervalTable)) != OK)
            {
               EXEC SQL ROLLBACK;
               return (ERROR);
            }        
         }

         /* Value exists in r_base so represents an update or insert */
         else
         {
            /* Select information from r_base to fill in a data record
               corresponding to the entry */
            EXEC SQL
               SELECT site_datatype_id,
                      TO_CHAR (start_date_time, 
                               'DD-MON-YYYY HH24:MI:SS'), 
                      TO_CHAR (end_date_time,
                               'DD-MON-YYYY HH24:MI:SS'),
                      value
               INTO :sqlDataRecord.siteDatatypeId,
                    :sqlDataRecord.startDateTime,
                    :sqlDataRecord.endDateTime,
                    :sqlDataRecord.value
               FROM r_base
               WHERE site_datatype_id = :sqlUpdateRecord->siteDatatypeId
                  AND start_date_time = TO_DATE (
                                           :sqlUpdateRecord->startDateTime,
                                           'DD-MON-YYYY HH24:MI:SS')
                  AND end_date_time = TO_DATE (
                                           :sqlUpdateRecord->endDateTime,
                                           'DD-MON-YYYY HH24:MI:SS')
                  AND interval = :sqlUpdateRecord->interval
                  AND overwrite_flag IS NULL;

            if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                          "Problem querying data record from r_base\n"))
                           != OK)
            {
               EXEC SQL ROLLBACK;
               return (ERROR);
            }

            /* Initialize the derivation flag to an empty string */
            strcpy (sqlDataRecord.derivationFlag, EMPTY_STRING);

            /* Is record valid for updating or inserting */
            if ((result = CheckCopy(&sqlDataRecord, refSource, &valid))
                 != OK)
            {
               FilePrintError(LOGFILE, "Problem verifying data record for copy\n");
               return (ERROR);
            }

            /* If valid, fill in other members of the data record */
            if (valid != 0)
            {
               /* Assign the dateTimeLoaded member */
               strcpy (sqlDataRecord.dateTimeLoaded, DATETIMELOADED);

               /* Assign the method_id for copy to the method member */
               sqlDataRecord.methodId = 6;

               /* Assign equivalent of NULL to the overwrite member */
               sqlDataRecord.overwrite = EMPTY_CHAR;    

               /* Assign indicator variable for the derivation flag
                  for future writing to the database */
               if (!strcmp(sqlDataRecord.derivationFlag, EMPTY_STRING))
               {
                  sqlDerFlag_ind = -1;
               }
               else
               {
                  sqlDerFlag_ind = 0;
               }   

            }

            /* Check to see if there is a value in the destination slot */   
            sprintf(selectStatement, "SELECT COUNT(*) FROM %s WHERE site_datatype_id = %d AND start_date_time = TO_DATE ('%s', 'DD-MON-YYYY HH24:MI:SS') AND end_date_time = TO_DATE ('%s', 'DD-MON-YYYY HH24:MI:SS') AND overwrite_flag IS NULL", intervalTable, sqlDataRecord.siteDatatypeId, sqlDataRecord.startDateTime, sqlDataRecord.endDateTime);

            if ((result = SqlSelectCount(selectStatement, &countDestination))                  != OK)
            {
               FilePrintError(LOGFILE, "Problem querying count for destination table\n");
               return (ERROR);
            }

            /* If value doesn't exist in destination, it is an insert */
            if (countDestination == 0)
            {
               /* If record is valid, insert it to destination table - invalid
                  records do not get inserted */
               if (valid != 0)
               {
                  EXEC SQL EXECUTE ins USING :sqlDataRecord.siteDatatypeId, :sqlDataRecord.startDateTime, :sqlDataRecord.endDateTime, :sqlDataRecord.value, :sqlDataRecord.methodId, :sqlDataRecord.derivationFlag :sqlDerFlag_ind, :sqlDataRecord.dateTimeLoaded;

                  if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME,
                                FALSE,
                                "Problem inserting data record (sdi: %d, start_date_time: %s) into %s\n", 
                                 sqlDataRecord.siteDatatypeId,
                                 sqlDataRecord.startDateTime,
                                 intervalTable)) != OK)
                  {
                     EXEC SQL ROLLBACK;
                     return (ERROR);
                  }        


               }
            }
            /* Value exists in destination so is an update */
            else
            {
               /* If new record to update the old is not valid, it is the 
                  equivalent of just deleting the old record */
               if (valid == 0)
               {
                  EXEC SQL EXECUTE del USING :sqlDataRecord.startDateTime, :sqlDataRecord.endDateTime;

                  if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME,
                                FALSE, 
                                "Problem deleting data record from %s\n", 
                                intervalTable)) != OK)
                  {
                     EXEC SQL ROLLBACK;
                     return (ERROR);
                  }
               }
               /* New record is valid and can be used to update the old one */
               else
               {
                  EXEC SQL EXECUTE upd USING :sqlDataRecord.value, :sqlDataRecord.methodId, :sqlDataRecord.derivationFlag :sqlDerFlag_ind, :sqlDataRecord.dateTimeLoaded,:sqlDataRecord.siteDatatypeId, :sqlDataRecord.startDateTime, :sqlDataRecord.endDateTime;

                  if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME,
                                FALSE, 
                                "Problem updating data record in %s\n", 
                                intervalTable)) != OK)
                  {
                     EXEC SQL ROLLBACK;
                     return (ERROR);
                  }  
               }
            }           
         }
      }
   }
   /* Values are associated with a business interval */
   else
   {
      /* Step through data list and insert, update, or delete in the
         interval table */
      for (updateIndex = 0; updateIndex < updateCount ; updateIndex++)
      {
         sqlUpdateRecord = &updateList[updateIndex];

         /* Get the destination interval times and the source data window
            times for this record */
         if ((result = SqlTimeInterval(sqlUpdateRecord, 
                                    sqlUpdateRecord->interval,
                                    &sqlIntervalTime,
                                    refSource)) != OK)
         {
            FilePrintError(LOGFILE, "Problem calculating interval times for copying interval data from r_base\n");
            return (ERROR);
         }

         /* Get count of data in the source data window */
         EXEC SQL
            SELECT COUNT(*) INTO :sqlCountSource
            FROM r_base 
            WHERE site_datatype_id = :sqlUpdateRecord->siteDatatypeId
               AND interval = :sqlUpdateRecord->interval
               AND overwrite_flag IS NULL
               AND start_date_time >= TO_DATE (:sqlIntervalTime.begSource,
                                               'DD-MON-YYYY HH24:MI:SS')
               AND end_date_time <= TO_DATE (:sqlIntervalTime.endSource,
                                            'DD-MON-YYYY HH24:MI:SS');

         if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                       "Problem querying for count of data in r_base\n")
                        )!= OK)
         {
            EXEC SQL ROLLBACK;
            return (ERROR);
         }

         /* If none are found, delete any value that may exist in the 
            destination interval */
         if (sqlCountSource == 0)
         {
            EXEC SQL EXECUTE del USING :sqlIntervalTime.begInterval, :sqlIntervalTime.endInterval;

            /* TRUE used in second argument to SqlFilePrintErrorHandler because
               it is OK if no rows were processed above - means a value hadn't 
               been previously copied to the destination table */
            if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, TRUE, 
                          "Problem deleting data record from %s\n", 
                          intervalTable)) != OK)
            {
               EXEC SQL ROLLBACK;
               return (ERROR);
            }        
         }
         /* Data exists in the source data window */
         else
         {
            /* Retrieve the source data value with the most recent 
               date_time_loaded */
            /* Declare sourcedata_cursor for selecting r_base source data 
               and order by descending date_time_loaded */
            EXEC SQL DECLARE sourceData_cursor CURSOR FOR
               SELECT site_datatype_id,
                      value
               FROM r_base
               WHERE site_datatype_id = :sqlUpdateRecord->siteDatatypeId
                  AND interval = :sqlUpdateRecord->interval
                  AND overwrite_flag IS NULL
                  AND start_date_time >= TO_DATE (:sqlIntervalTime.begSource,
                                      'DD-MON-YYYY HH24:MI:SS')
                  AND end_date_time <= TO_DATE (:sqlIntervalTime.endSource,
                                      'DD-MON-YYYY HH24:MI:SS')
               ORDER BY date_time_loaded DESC;

            if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
               "Problem declaring sourceData_cursor\n")) != OK)
            {
               return (ERROR);
            }

            /* Open sourceData_cursor */
            EXEC SQL OPEN sourceData_cursor;
            if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
               "Problem opening sourceData_cursor\n")) != OK)
            {
               return (ERROR);
            }

            /* Fetch first r_base entry with sourcedData_cursor - this is
               the one with the most recent date_time_loaded - don't
               need to load any others that may be in the active set */
            EXEC SQL FETCH sourceData_cursor
               INTO :sqlDataRecord.siteDatatypeId,
                    :sqlDataRecord.value; 

            if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                "Problem fetching sourceData_cursor\n")) != OK)
            {
               EXEC SQL ROLLBACK;
               return (ERROR);
            }

            /* Close sourceData_cursor */
            EXEC SQL CLOSE sourceData_cursor;
            EXEC SQL COMMIT;

            /* Initialize the derivation flag to an empty string */
            strcpy (sqlDataRecord.derivationFlag, EMPTY_STRING);

            /* Assign beginning of interval time to startDateTime member */
            strcpy (sqlDataRecord.startDateTime,
                    sqlIntervalTime.begInterval);

            /* Assign end of interval time to endDateTime member */
            strcpy (sqlDataRecord.endDateTime,
                    sqlIntervalTime.endInterval);

            /* Assign the dateTimeLoaded member */
            strcpy (sqlDataRecord.dateTimeLoaded, DATETIMELOADED);

            /* Assign the method_id for copy to the method member */
            sqlDataRecord.methodId = 6;

            /* Assign equivalent of NULL to the overwrite member */
            sqlDataRecord.overwrite = EMPTY_CHAR;    

            /* Is record valid for updating or inserting */
            if ((result = CheckCopy(&sqlDataRecord, refSource, &valid))
                 != OK)
            {
               FilePrintError(LOGFILE, "Problem verifying data record for copy\n");
               return (ERROR);
            }

            /* Assign indicator variable for the derivation flag
               for future writing to the database */
            if (!strcmp(sqlDataRecord.derivationFlag, EMPTY_STRING))
            {
               sqlDerFlag_ind = -1;
            }
            else
            {
               sqlDerFlag_ind = 0;
            }


            /* Check to see if there is a value in the destination slot */   
            sprintf(selectStatement, "SELECT COUNT(*) FROM %s WHERE site_datatype_id = %d AND start_date_time = TO_DATE ('%s', 'DD-MON-YYYY HH24:MI:SS') AND end_date_time = TO_DATE ('%s', 'DD-MON-YYYY HH24:MI:SS')", intervalTable, sqlDataRecord.siteDatatypeId, sqlDataRecord.startDateTime, sqlDataRecord.endDateTime);

            if ((result = SqlSelectCount(selectStatement, &countDestination))                  != OK)
            {
               FilePrintError(LOGFILE, "Problem querying count for destination slot\n");
               return (ERROR);
            }

            /* If value doesn't exist in destination table, it is an insert */
            if (countDestination == 0)
            {
               /* If record is valid, insert it to destination table - invalid
                  records do not get inserted */
               if (valid != 0)
               {
                  EXEC SQL EXECUTE ins USING :sqlDataRecord.siteDatatypeId, :sqlDataRecord.startDateTime, :sqlDataRecord.endDateTime, :sqlDataRecord.value, :sqlDataRecord.methodId, :sqlDataRecord.derivationFlag :sqlDerFlag_ind, :sqlDataRecord.dateTimeLoaded;

                  if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME,
                                FALSE, 
                                "Problem inserting data record into %s\n", 
                                 intervalTable)) != OK)
                  {
                     EXEC SQL ROLLBACK;
                     return (ERROR);
                  }        
               }
            }

            /* Value already exists in destination slot, so is an update */
            else
            {
               /* If new record to update the old is not valid, it is the 
                  equivalent of just deleting the old record */
               if (valid == 0)
               {
                  EXEC SQL EXECUTE del USING :sqlDataRecord.startDateTime, :sqlDataRecord.endDateTime;

                  if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME,
                                FALSE, 
                                "Problem deleting data record from %s\n", 
                                intervalTable)) != OK)
                  {
                     EXEC SQL ROLLBACK;
                     return (ERROR);
                  }
               }
               /* New record is valid and can be used to update the old one */
               else
               {
                  EXEC SQL EXECUTE upd USING :sqlDataRecord.value, :sqlDataRecord.methodId, :sqlDataRecord.derivationFlag :sqlDerFlag_ind, :sqlDataRecord.dateTimeLoaded,:sqlDataRecord.siteDatatypeId, :sqlDataRecord.startDateTime, :sqlDataRecord.endDateTime;

                  if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME,
                                FALSE, 
                                "Problem updating data record in %s\n", 
                                intervalTable)) != OK)
                  {
                     EXEC SQL ROLLBACK;
                     return (ERROR);
                  }                  
               }
            }
         }
      }
   }

   EXEC SQL COMMIT;    
   return (OK);
} 

/****************************************************************************/
#define FUNC_NAME "SqlTimeInterval"

int SqlTimeInterval(UPDATE_RECORD* updateRecord, SQL_INTERVAL destInterval,
                    INTERVAL_TIME* timeRecord, REF_SOURCE* refSource)
{
   /* Find the destination interval and source window for a given date/time */

   EXEC SQL BEGIN DECLARE SECTION;
      int sqlCurrentCount;
      int sqlOffset;
      SQL_INTERVAL sqlCurrentInterval;
      SQL_INTERVAL_UNIT sqlCurrentUnit;
      SQL_INTERVAL sqlDestInterval;
      SQL_INTERVAL_UNIT sqlDestUnit;
   EXEC SQL END DECLARE SECTION;

   int positiveValue;
   int result;
   int valid;
   SQL_DATE begInterval;
   SQL_DATE endInterval;
   SQL_DATE begSource;
   SQL_DATE endSource;
   SQL_INTERVAL previousInterval;


   /* Set begInterval equal to given startDateTime */
   strcpy (begInterval, updateRecord->startDateTime);

   /* Set sqlDestInterval variable */
   strcpy (sqlDestInterval, destInterval);   

   /* Subtract the time offset, if applicable */
   if (refSource != NULL)
   {
      /* If time offset is specified */
      if (refSource->timeOffsetMinutes != VALUE_NULL)
      {
         if (refSource->timeOffsetMinutes < 0 )
         {
            /* Subtracting a negative so need ADDITION of the 
               positive value for SqlDateMath */
            positiveValue = (-1) * refSource->timeOffsetMinutes; 
            if ((result = SqlDateMath(ADDITION, begInterval, begInterval, 
                                      positiveValue,
                                      MINUTE)) != OK)
            {
               FilePrintError(LOGFILE, "Problem subtracting time offset");
               return (ERROR);
            }
         }
         else
         {
            /* Call SUBTRACTION */
            if ((result = SqlDateMath(SUBTRACTION, begInterval, begInterval, 
                                      refSource->timeOffsetMinutes,
                                      MINUTE)) != OK)
            {
               FilePrintError(LOGFILE, "Problem subtracting time offset");
               return (ERROR);
            }
         }
      }
   }

   /* Set currentInterval to be the destination interval */
   strcpy (sqlCurrentInterval, sqlDestInterval);

   /* Subtract interval redefinitions for the destination interval down to,
      but not including the interval of the given updateRecord */
   while (strcmp (sqlCurrentInterval, updateRecord->interval))
   {
      /* Check to see if there is an interval redefinition row for the 
         current interval (can only be one since this is the primary key) */
      EXEC SQL
         SELECT COUNT(*) INTO :sqlCurrentCount
         FROM ref_interval_redefinition 
         WHERE interval = :sqlCurrentInterval;

      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                    "Problem getting count from ref_interval_redefinition\n"))
                     != OK)
      {
         EXEC SQL ROLLBACK;
         return (ERROR);
      }

      /* If redefinition exists, retrieve and subtract it from begInterval */
      if (sqlCurrentCount != 0)
      {
         EXEC SQL SELECT time_offset, offset_units
            INTO :sqlOffset, :sqlCurrentUnit
            FROM ref_interval_redefinition
            WHERE interval = :sqlCurrentInterval;

         if ((result = SqlFilePrintErrorHandler (LOGFILE, FUNC_NAME, FALSE,
            "Problem selecting interval redefinition for the interval %s\n",
             sqlCurrentInterval)) != OK)
         {
            return (ERROR);
         }

         if (sqlOffset < 0)
         {
            /* Subtracting a negative so need ADDITION of the positive
               value in SqlDateMath */
            positiveValue = (-1) * sqlOffset;
            if ((result = SqlDateMath(ADDITION, begInterval, begInterval, 
                                      positiveValue, sqlCurrentUnit)) != OK)
            {
               FilePrintError(LOGFILE, "Problem subtracting interval redefinition for %s\n",
                           sqlCurrentInterval);
               return (ERROR);
            } 
         }
         else
         {
            /* Call SUBTRACTION */
            if ((result = SqlDateMath(SUBTRACTION, begInterval, begInterval, 
                                      sqlOffset, sqlCurrentUnit)) != OK)
            {
               FilePrintError(LOGFILE, "Problem subtracting interval redefinition for %s\n",
                           sqlCurrentInterval);
               return (ERROR);
            }
         }
      }

      /* Decrement to the previous interval */
      if ((result = SqlGetPreviousIntName(sqlCurrentInterval,
                    previousInterval,
                    &valid)) != OK)
      {
         FilePrintError(LOGFILE, "Problem finding previous interval name for interval %s\n", sqlCurrentInterval);
         return (ERROR);
      }

      /* If previous interval name is not valid, means you have reached the
         smallest business interval, so can break loop and continue */
      if (valid == 0)
      {
         break;
      }

      strcpy (sqlCurrentInterval, previousInterval);
   }

   /* Truncate begInterval to part corresponding to destination interval */
   EXEC SQL SELECT interval_unit
      INTO :sqlDestUnit
      FROM hdb_interval
      WHERE interval_name = :sqlDestInterval;

   if ((result = SqlFilePrintErrorHandler (LOGFILE, FUNC_NAME, FALSE,
      "Problem selecting sql_unit for the interval %s\n",
       sqlDestInterval)) != OK)
   {
      return (ERROR);
   }

   if ((result = SqlDateTrunc(begInterval, sqlDestUnit, begInterval)) != OK)
   {
      FilePrintError(LOGFILE, "Problem truncating date to %s\n", sqlDestInterval);
      return (ERROR);
   }      

   /* Set currentInterval to be the destination interval */
   strcpy (sqlCurrentInterval, sqlDestInterval);

   /* Add back in the interval redefinitions for the destination interval
      down to, but not including the interval of the given updateRecord */
   while (strcmp (sqlCurrentInterval, updateRecord->interval))
   {
      /* Check to see if there is an interval redefinition row for the 
         current interval (can only be one since this is the primary key) */
      EXEC SQL
         SELECT COUNT(*) INTO :sqlCurrentCount
         FROM ref_interval_redefinition 
         WHERE interval = :sqlCurrentInterval;

      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                    "Problem getting count from ref_interval_redefinition\n"))
                     != OK)
      {
         EXEC SQL ROLLBACK;
         return (ERROR);
      }

      /* If redefinition exists, retrieve and add it to begInterval */
      if (sqlCurrentCount != 0)
      {
         EXEC SQL SELECT time_offset, offset_units
            INTO :sqlOffset, :sqlCurrentUnit
            FROM ref_interval_redefinition
            WHERE interval = :sqlCurrentInterval;

         if ((result = SqlFilePrintErrorHandler (LOGFILE, FUNC_NAME, FALSE,
            "Problem selecting interval redefinition for the interval %s\n",
             sqlCurrentInterval)) != OK)
         {
            return (ERROR);
         }

         if (sqlOffset < 0)
         {
            /* Are adding a negative so need to call SUBTRACTION of the
               positive value for SqlDateMath */
            positiveValue = (-1) * sqlOffset;
            if ((result = SqlDateMath(SUBTRACTION, begInterval, begInterval, 
                                      positiveValue, sqlCurrentUnit)) != OK)
            {
               FilePrintError(LOGFILE, "Problem adding interval redefinition for %s\n",
                           sqlCurrentInterval);
               return (ERROR);
            }            
         }
         else
         {
            /* Call ADDITION */
            if ((result = SqlDateMath(ADDITION, begInterval, begInterval, 
                                      sqlOffset, sqlCurrentUnit)) != OK)
            {
               FilePrintError(LOGFILE, "Problem adding interval redefinition for %s\n",
                           sqlCurrentInterval);
               return (ERROR);
            }
         }
      }

      /* Decrement to the previous interval */
      if ((result = SqlGetPreviousIntName(sqlCurrentInterval,
                    previousInterval,
                    &valid)) != OK)
      {
         FilePrintError(LOGFILE, "Problem finding previous interval name for interval %s\n", sqlCurrentInterval);
         return (ERROR);
      }

      /* If previous interval name is not valid, means you have reached the
         smallest business interval, so can break loop and continue */
      if (valid == 0)
      {
         break;
      }

      strcpy (sqlCurrentInterval, previousInterval);
   }

   /* Result here is the beginning of the destination interval that the 
      original given value falls into */
   strcpy (timeRecord->begInterval, begInterval);

   /* End of the destination interval is the beginning time plus the 
      destination interval period */
   if ((result = SqlDateMath(ADDITION, begInterval, endInterval, 
                             1, sqlDestUnit)) != OK)
   {
      FilePrintError(LOGFILE, "Problem adding destination interval length for %s\n",
         sqlDestInterval);
      return (ERROR);
   }
   strcpy (timeRecord->endInterval, endInterval);

   /* Beginning of the source data window is beginning of the destination
      interval plus the time offset, if one is applicable */
   strcpy (begSource, begInterval); 
   if (refSource != NULL)
   {
      /* If time offset is specified */
      if (refSource->timeOffsetMinutes != VALUE_NULL)
      {
         if (refSource->timeOffsetMinutes < 0)
         {
            /* Are adding a negative so need to call SUBTRACTION of the
               positive value for SqlDateMath */
            positiveValue = (-1) * refSource->timeOffsetMinutes;
            if ((result = SqlDateMath(SUBTRACTION, begSource, begSource, 
                                      positiveValue,
                                      MINUTE)) != OK)
            {
               FilePrintError(LOGFILE, "Problem adding time offset");
               return (ERROR);
            }
         }
         else
         {
            /* Call ADDITION */
            if ((result = SqlDateMath(ADDITION, begSource, begSource, 
                                      refSource->timeOffsetMinutes,
                                      MINUTE)) != OK)
            {
               FilePrintError(LOGFILE, "Problem adding time offset");
               return (ERROR);
            }
         }
      }
   }
   strcpy (timeRecord->begSource, begSource);

   /* End of the source data window is beginning source window time plus the
      destination interval period */
   if ((result = SqlDateMath(ADDITION, begSource, endSource, 
                             1, sqlDestUnit)) != OK)
   {
      FilePrintError(LOGFILE, "Problem adding destination interval length for %s\n",
         sqlDestInterval);
      return (ERROR);
   }
   strcpy (timeRecord->endSource, endSource);   

   EXEC SQL COMMIT;    
   return (OK);
}

/****************************************************************************/
#define FUNC_NAME "SqlTimeShift"

int SqlTimeShift(INTERVAL_TIME* timeRecord, SQL_INTERVAL destInterval,
                 DATE_MATH_TYPES op, INTERVAL_TIME* newRecord)
{
   /* This function shifts a time record forward or backward by one
      interval */

   EXEC SQL BEGIN DECLARE SECTION;
      SQL_INTERVAL sqlDestInterval;
      SQL_INTERVAL_UNIT sqlDestUnit;
   EXEC SQL END DECLARE SECTION;

   int result;

   /* Initialize the sql variable */
   strcpy(sqlDestInterval, destInterval);

   /* Retrieve the sql unit for the interval */
   EXEC SQL SELECT interval_unit
      INTO :sqlDestUnit
      FROM hdb_interval
      WHERE interval_name = :sqlDestInterval;

   if ((result = SqlFilePrintErrorHandler (LOGFILE, FUNC_NAME, FALSE,
      "Problem selecting interval_unit for the interval %s\n",
       sqlDestInterval)) != OK)
   {
      return (ERROR);
   }

   /* Each member of the time structure needs to be adjusted */
   if ((result = SqlDateMath(op, timeRecord->begInterval,
                             newRecord->begInterval, 
                             1, sqlDestUnit)) != OK)
   {
      FilePrintError(LOGFILE, "Problem shifting begInterval time in time record\n");
      return (ERROR);
   }
   if ((result = SqlDateMath(op, timeRecord->endInterval,
                             newRecord->endInterval, 
                             1, sqlDestUnit)) != OK)
   {
      FilePrintError(LOGFILE, "Problem shifting endInterval time in time record\n");
      return (ERROR);
   }
   if ((result = SqlDateMath(op, timeRecord->begSource,
                             newRecord->begSource, 
                             1, sqlDestUnit)) != OK)
   {
      FilePrintError(LOGFILE, "Problem shifting begSource time in time record\n");
      return (ERROR);
   }
   if ((result = SqlDateMath(op, timeRecord->endSource,
                             newRecord->endSource, 
                             1, sqlDestUnit)) != OK)
   {
      FilePrintError(LOGFILE, "Problem shifting endSource time in time record\n");
      return (ERROR);
   }

   EXEC SQL COMMIT;    
   return (OK);
}

/****************************************************************************/
#define FUNC_NAME "SqlCreateTable"

int SqlCreateTable()
{
   /* Creating the r_interval_update table for the internal use of
      the derivation application also acts as a semafore to assure that
      only one copy of the application is running at a time on a 
      database */

   int result;

   /* Create r_interval_update table */
   EXEC SQL CREATE TABLE r_interval_update
      (site_datatype_id             NUMBER,
       interval                     VARCHAR2(16),
       start_date_time              DATE,
       end_date_time                DATE,
       CONSTRAINT  r_interval_update_pk
          PRIMARY KEY (site_datatype_id, interval,
                    start_date_time, end_date_time)
      );

   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
      "Problem creating r_interval_update table\n")) != OK)
   {
         return (ERROR);
   }

   EXEC SQL COMMIT;    
   return (OK);
}

/****************************************************************************/
#define FUNC_NAME "SqlDropTable"

int SqlDropTable()
{
   /* This function drops the r_interval_update table that was used
      during the run of the derivation application.  This also releases
      the semafore effect of the table so that another copy of the derivation 
      application can now be run. */

   int result;

   /* Drop r_interval_update table */
   EXEC SQL DROP TABLE r_interval_update;

   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
      "Problem dropping the r_interval_update table\n")) != OK)
   {
         return (ERROR);
   }

   EXEC SQL COMMIT;    
   return (OK);
}

/****************************************************************************/
#define FUNC_NAME "LoadDestination"

int LoadDestination(REF_DESTINATION* sourceSpec,
                    IND_DESTINATION* indicatorSource,
                    REF_DESTINATION* outputSpec)
{
   /* This function takes a specification that has been loaded with sql 
      from the ref_derivation_destination table and does NULL checking
      based on the associated indicator variable while loading the spec
      to another REF_DESTINATION structure */
  
         outputSpec->baseSDI = sourceSpec->baseSDI;
         if (indicatorSource->compoundingSourceSDI_ind == -1)
         {
            outputSpec->compoundingSourceSDI = VALUE_NULL;
         }
         else
         {
            outputSpec->compoundingSourceSDI = 
                                     sourceSpec->compoundingSourceSDI;
         }
         if (indicatorSource->compoundingSourceInterval_ind == -1)
         {
            strcpy (outputSpec->compoundingSourceInterval,
                    EMPTY_STRING);
         }
         else
         {
            strcpy (outputSpec->compoundingSourceInterval, 
                    sourceSpec->compoundingSourceInterval);
         }
         outputSpec->destSDI = sourceSpec->destSDI;
         if (indicatorSource->partialCalc_ind == -1)
         {
            outputSpec->partialCalc = EMPTY_CHAR;
         }
         else
         {
            outputSpec->partialCalc = 
                                     sourceSpec->partialCalc;
         }
         outputSpec->methodId = sourceSpec->methodId;
         if (indicatorSource->hrDesiredEopWindow_ind == -1)
         {
            outputSpec->hrDesiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->hrDesiredEopWindow = 
                                    sourceSpec->hrDesiredEopWindow;
         }
         if (indicatorSource->hrRequiredEopWindow_ind == -1)
         {
            outputSpec->hrRequiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->hrRequiredEopWindow = 
                                    sourceSpec->hrRequiredEopWindow;
         }
         if (indicatorSource->hrDesiredBopWindow_ind == -1)
         {
            outputSpec->hrDesiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->hrDesiredBopWindow = 
                                    sourceSpec->hrDesiredBopWindow;
         }
         if (indicatorSource->hrRequiredBopWindow_ind == -1)
         {
            outputSpec->hrRequiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->hrRequiredBopWindow = 
                                    sourceSpec->hrRequiredBopWindow;
         }
         if (indicatorSource->hrWindowUnit_ind == -1)
         {
            strcpy (outputSpec->hrWindowUnit, EMPTY_STRING);
         }
         else
         {
            strcpy (outputSpec->hrWindowUnit, 
                    sourceSpec->hrWindowUnit);
         }
         if (indicatorSource->hrDesiredNumSource_ind == -1)
         {
            outputSpec->hrDesiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->hrDesiredNumSource = 
                                    sourceSpec->hrDesiredNumSource;
         }
         if (indicatorSource->hrRequiredNumSource_ind == -1)
         {
            outputSpec->hrRequiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->hrRequiredNumSource = 
                                    sourceSpec->hrRequiredNumSource;
         }

         if (indicatorSource->dayDesiredEopWindow_ind == -1)
         {
            outputSpec->dayDesiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->dayDesiredEopWindow = 
                                    sourceSpec->dayDesiredEopWindow;
         }
         if (indicatorSource->dayRequiredEopWindow_ind == -1)
         {
            outputSpec->dayRequiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->dayRequiredEopWindow = 
                                    sourceSpec->dayRequiredEopWindow;
         }
         if (indicatorSource->dayDesiredBopWindow_ind == -1)
         {
            outputSpec->dayDesiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->dayDesiredBopWindow = 
                                    sourceSpec->dayDesiredBopWindow;
         }
         if (indicatorSource->dayRequiredBopWindow_ind == -1)
         {
            outputSpec->dayRequiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->dayRequiredBopWindow = 
                                    sourceSpec->dayRequiredBopWindow;
         }
         if (indicatorSource->dayWindowUnit_ind == -1)
         {
            strcpy (outputSpec->dayWindowUnit, EMPTY_STRING);
         }
         else
         {
            strcpy (outputSpec->dayWindowUnit, 
                    sourceSpec->dayWindowUnit);
         }
         if (indicatorSource->dayDesiredNumSource_ind == -1)
         {
            outputSpec->dayDesiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->dayDesiredNumSource = 
                                    sourceSpec->dayDesiredNumSource;
         }
         if (indicatorSource->dayRequiredNumSource_ind == -1)
         {
            outputSpec->dayRequiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->dayRequiredNumSource = 
                                    sourceSpec->dayRequiredNumSource;
         }
         if (indicatorSource->monDesiredEopWindow_ind == -1)
         {
            outputSpec->monDesiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->monDesiredEopWindow = 
                                    sourceSpec->monDesiredEopWindow;
         }
         if (indicatorSource->monRequiredEopWindow_ind == -1)
         {
            outputSpec->monRequiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->monRequiredEopWindow = 
                                    sourceSpec->monRequiredEopWindow;
         }
         if (indicatorSource->monDesiredBopWindow_ind == -1)
         {
            outputSpec->monDesiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->monDesiredBopWindow = 
                                    sourceSpec->monDesiredBopWindow;
         }
         if (indicatorSource->monRequiredBopWindow_ind == -1)
         {
            outputSpec->monRequiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->monRequiredBopWindow = 
                                    sourceSpec->monRequiredBopWindow;
         }
         if (indicatorSource->monWindowUnit_ind == -1)
         {
            strcpy (outputSpec->monWindowUnit, EMPTY_STRING);
         }
         else
         {
            strcpy (outputSpec->monWindowUnit, 
                    sourceSpec->monWindowUnit);
         }
         if (indicatorSource->monDesiredNumSource_ind == -1)
         {
            outputSpec->monDesiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->monDesiredNumSource = 
                                    sourceSpec->monDesiredNumSource;
         }
         if (indicatorSource->monRequiredNumSource_ind == -1)
         {
            outputSpec->monRequiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->monRequiredNumSource = 
                                    sourceSpec->monRequiredNumSource;
         }
         if (indicatorSource->yrDesiredEopWindow_ind == -1)
         {
            outputSpec->yrDesiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->yrDesiredEopWindow = 
                                    sourceSpec->yrDesiredEopWindow;
         }
         if (indicatorSource->yrRequiredEopWindow_ind == -1)
         {
            outputSpec->yrRequiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->yrRequiredEopWindow = 
                                    sourceSpec->yrRequiredEopWindow;
         }
         if (indicatorSource->yrDesiredBopWindow_ind == -1)
         {
            outputSpec->yrDesiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->yrDesiredBopWindow = 
                                    sourceSpec->yrDesiredBopWindow;
         }
         if (indicatorSource->yrRequiredBopWindow_ind == -1)
         {
            outputSpec->yrRequiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->yrRequiredBopWindow = 
                                    sourceSpec->yrRequiredBopWindow;
         }
         if (indicatorSource->yrWindowUnit_ind == -1)
         {
            strcpy (outputSpec->yrWindowUnit, EMPTY_STRING);
         }
         else
         {
            strcpy (outputSpec->yrWindowUnit, 
                    sourceSpec->yrWindowUnit);
         }
         if (indicatorSource->yrDesiredNumSource_ind == -1)
         {
            outputSpec->yrDesiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->yrDesiredNumSource = 
                                    sourceSpec->yrDesiredNumSource;
         }
         if (indicatorSource->yrRequiredNumSource_ind == -1)
         {
            outputSpec->yrRequiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->yrRequiredNumSource = 
                                    sourceSpec->yrRequiredNumSource;
         }
         if (indicatorSource->wyDesiredEopWindow_ind == -1)
         {
            outputSpec->wyDesiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->wyDesiredEopWindow = 
                                    sourceSpec->wyDesiredEopWindow;
         }
         if (indicatorSource->wyRequiredEopWindow_ind == -1)
         {
            outputSpec->wyRequiredEopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->wyRequiredEopWindow = 
                                    sourceSpec->wyRequiredEopWindow;
         }
         if (indicatorSource->wyDesiredBopWindow_ind == -1)
         {
            outputSpec->wyDesiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->wyDesiredBopWindow = 
                                    sourceSpec->wyDesiredBopWindow;
         }
         if (indicatorSource->wyRequiredBopWindow_ind == -1)
         {
            outputSpec->wyRequiredBopWindow = VALUE_NULL;
         }
         else
         {
            outputSpec->wyRequiredBopWindow = 
                                    sourceSpec->wyRequiredBopWindow;
         }
         if (indicatorSource->wyWindowUnit_ind == -1)
         {
            strcpy (outputSpec->wyWindowUnit, EMPTY_STRING);
         }
         else
         {
            strcpy (outputSpec->wyWindowUnit, 
                    sourceSpec->wyWindowUnit);
         }
         if (indicatorSource->wyDesiredNumSource_ind == -1)
         {
            outputSpec->wyDesiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->wyDesiredNumSource = 
                                    sourceSpec->wyDesiredNumSource;
         }
         if (indicatorSource->wyRequiredNumSource_ind == -1)
         {
            outputSpec->wyRequiredNumSource = VALUE_NULL;
         }
         else
         {
            outputSpec->wyRequiredNumSource = 
                                    sourceSpec->wyRequiredNumSource;
         }

   return (OK);
}

/****************************************************************************/
#define FUNC_NAME "SqlUpdateSelect"

int SqlUpdateSelect(int siteDatatypeId,
                    SQL_INTERVAL sourceInterval,
                    int* updateCount,
                    UPDATE_RECORD** updateList )
{
   /* This function retrieves update data from the r_interval_update table */

   /* NOTE:  THE USER OF THIS METHOD IS RESPONSIBLE FOR FREEING THE MEMORY
             THAT IS ALLOCATED TO updateList BY MALLOC IF UPDATE DATA IS
             RETRIEVED */

   EXEC SQL BEGIN DECLARE SECTION;
      char sqlSelectStatement[600];
      UPDATE_RECORD* sqlUpdateRecord;
   EXEC SQL END DECLARE SECTION;

   char selectStatement[600];
   int result;
   int updateIndex;


   /* Load rows from r_interval_update that belong to the
      site datatype and interval  */
   /* Find out how many applicable rows in r_interval_update */
   sprintf(selectStatement, "SELECT COUNT(*) FROM r_interval_update WHERE site_datatype_id = %d AND interval = '%s'", siteDatatypeId, sourceInterval);

   if ((result = SqlSelectCount(selectStatement, updateCount)) != OK)
   {
      FilePrintError(LOGFILE, "Problem querying row count in r_interval_update\n");
      return (ERROR);
   }

   /* Create array of structures to hold r_interval_update data */
   if (*updateCount)
   {
      if ((*updateList = (UPDATE_RECORD *) malloc 
         (sizeof(UPDATE_RECORD) * (*updateCount))) == NULL)
      {
          FilePrintError(LOGFILE, "Problem allocating memory for intUpdateDataList\n");
          return (ERROR);
      }
   }
   else
   {
      *updateList = NULL;
      return (OK);
   }

   /* Prepare the select statement for r_interval_update data*/
   sprintf (sqlSelectStatement, "SELECT site_datatype_id, TO_CHAR (start_date_time, 'DD-MON-YYYY HH24:MI:SS'), TO_CHAR (end_date_time, 'DD-MON-YYYY HH24:MI:SS'), interval FROM r_interval_update WHERE site_datatype_id = %d AND interval = '%s' ORDER BY start_date_time", siteDatatypeId, sourceInterval);

   EXEC SQL PREPARE sel FROM :sqlSelectStatement;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                 "Problem preparing select statement: %s...\n",
                 sqlSelectStatement)) != OK)
   {
      return (ERROR);
   }

   /* Declare int_update_cursor to select r_interval_update data */
   EXEC SQL DECLARE int_update_cursor CURSOR FOR sel;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE, 
                 "Problem declaring int_update_cursor for: %s...\n",
                 sqlSelectStatement)) != OK)
   {
      return (ERROR);
   }

   /* Open int_update_cursor */
   EXEC SQL OPEN int_update_cursor;
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
                 "Problem opening int_update_cursor for\n: %s...\n",
                 sqlSelectStatement)) != OK)
   {
      return (ERROR);
   }

   EXEC SQL WHENEVER NOT FOUND GOTO close_int_update_cursor;

   /* Fetch applicable r_interval_update data */ 
   for (updateIndex = 0; updateIndex < *updateCount ;
        updateIndex++)
   {
      sqlUpdateRecord = &((*updateList)[updateIndex]);

      EXEC SQL FETCH int_update_cursor INTO
                       :sqlUpdateRecord->siteDatatypeId, 
                       :sqlUpdateRecord->startDateTime,
                       :sqlUpdateRecord->endDateTime,
                       :sqlUpdateRecord->interval;
      if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, FALSE,
           "Problem fetching int_update_cursor for\n: %s...\n",
           sqlSelectStatement)) != OK)
      {
         EXEC SQL ROLLBACK;
         return (ERROR);
      }
   }

   /* Close int_update_cursor */
   close_int_update_cursor:
   EXEC SQL CLOSE int_update_cursor;
   EXEC SQL COMMIT;
   EXEC SQL WHENEVER NOT FOUND CONTINUE;

   return (OK);
}

/****************************************************************************/
#define FUNC_NAME "SqlRemoveOldUpdates"

int SqlRemoveOldUpdates()
{
   /* This function removes seed records from r_base_update that are over
      one year old. These could no longer function as the one latest residual
      value to keep to make sure a partial calc at the longest interval (year) 
      eventually is made final. At this point they would represent an SDI that
      no longer has new data coming in. */

   EXEC SQL BEGIN DECLARE SECTION;
      SQL_DATE sqlLastYear;
   EXEC SQL END DECLARE SECTION;

   int result;


   /* Sutract a year from the current run time of the app */
   if ((result = SqlDateMath(SUBTRACTION,
                             DATETIMELOADED,
                             sqlLastYear, 
                             1,
                             YEAR)) != OK)
   {
      FilePrintError(LOGFILE, "Problem finding last year's time");
      return (ERROR);
   }

   /* Delete old seed reocrds from r_base_update */
   EXEC SQL DELETE FROM r_base_update
      WHERE end_date_time < TO_DATE (:sqlLastYear, 'DD-MON-YYYY HH24:MI:SS')
      AND ready_for_delete = 'S';

   /* TRUE used in second argument to SqlFilePrintErrorHandler because it
      is OK if no rows were processed above - means there are no 
      old records to delete */
   if ((result = SqlFilePrintErrorHandler(LOGFILE, FUNC_NAME, TRUE,
      "Problem deleting old records from r_base_update \n")) != OK)
   {
         return (ERROR);
   }

   EXEC SQL COMMIT;    
   return (OK);
}
